search_uri,
query = query_params,
add_headers(Authorization = paste("bearer", yelp_key))
)
response_text <- content(response, type = "text")
response_data <- fromJSON(response_text)
restaurants <- flatten(response_data$businesses)
#each set of restaurants pulled is added to the restaurant list
restaurant_list[[i]] <- restaurants
offset_counter <- offset_counter + 50
#Test code, ignore
#restaurants %>% select(name, location.zip_code) %>% filter(location.zip_code == 77002) %>% arrange(location.zip_code)
}
#if working, this code would compile all listed dataframes into a master dataframe, containing many restaurants
masterlist <-bind_rows(restaurant_list)
restaurant_list = list()
#THE ACTUAL FOR LOOP I'LL NEED
#for(i in 1:length(harris_zips$zip_code)){#function_body}
#THE 'TEST' FOR LOOP I'LL BE USING
for(i in 1:3){
#the offset determines which results based on a certain query are returned.
#Increasing the offset counter should return a new set of results with each query
offset_counter <- 1
restaurant_length <- 50
while(restaurant_length >= 50){ #this loop will break if less than 50 restaurants are returned
location_query <- harris_data_by_zip$zip_code[i] #queries zip code based on position in the harris_data_by_zip file
query_params <- list(
term = "Restaurants",
location = location_query, #need to find a way to iterate location query by zip
#sort_by = "rating", #this will filter out results with very few or low ratings
#use a while loop to break loop if less than 50 results are returned
limit = 50,
offset = offset_counter
)
response <- GET(
search_uri,
query = query_params,
add_headers(Authorization = paste("bearer", yelp_key))
)
response_text <- content(response, type = "text")
response_data <- fromJSON(response_text)
restaurants <- flatten(response_data$businesses)
#each set of restaurants pulled is added to the restaurant list
restaurant_list[[i]] <- restaurants
restaurant_length <- nrow(restaurants)
offset_counter <- offset_counter + 50
}
#Test code, ignore
#restaurants %>% select(name, location.zip_code) %>% filter(location.zip_code == 77002) %>% arrange(location.zip_code)
}
restaurant_list = list()
#THE 'TEST' FOR LOOP I'LL BE USING
offset_counter <- 1
for(i in 1:20){
query_params <- list(
term = "Restaurants",
location = "Houston, TX", #need to find a way to iterate location query by zip
#sort_by = "rating", #this will filter out results with very few or low ratings
#use a while loop to break loop if less than 50 results are returned
limit = 50,
offset = offset_counter
)
response <- GET(
search_uri,
query = query_params,
add_headers(Authorization = paste("bearer", yelp_key))
)
response_text <- content(response, type = "text")
response_data <- fromJSON(response_text)
restaurants <- flatten(response_data$businesses)
#each set of restaurants pulled is added to the restaurant list
restaurant_list[[i]] <- restaurants
offset_counter <- offset_counter + 50
#Test code, ignore
#restaurants %>% select(name, location.zip_code) %>% filter(location.zip_code == 77002) %>% arrange(location.zip_code)
}
restaurant_list = list()
#THE 'TEST' FOR LOOP I'LL BE USING
offset_counter <- 1
results_returned <- 50
for(i in 1:20){
if (offset_counter == 951 ){
results_returned <- 49
}else{
results_returned <- 50
}
query_params <- list(
term = "Restaurants",
location = "Houston, TX", #need to find a way to iterate location query by zip
#sort_by = "rating", #this will filter out results with very few or low ratings
#use a while loop to break loop if less than 50 results are returned
limit = results_returned,
offset = offset_counter
)
response <- GET(
search_uri,
query = query_params,
add_headers(Authorization = paste("bearer", yelp_key))
)
response_text <- content(response, type = "text")
response_data <- fromJSON(response_text)
restaurants <- flatten(response_data$businesses)
#each set of restaurants pulled is added to the restaurant list
restaurant_list[[i]] <- restaurants
offset_counter <- offset_counter + 50
#Test code, ignore
#restaurants %>% select(name, location.zip_code) %>% filter(location.zip_code == 77002) %>% arrange(location.zip_code)
}
#if working, this code would compile all listed dataframes into a master dataframe, containing many restaurants
masterlist <-bind_rows(restaurant_list)
masterlist
unique(masterlist$location.city)
masterlist %>%
filter(location.city == "Carle Place" | location.city == "New York")
masterlist %>%
filter(location.city == "Carle Place" | location.city == "New York" | location.city == "HOUSTON") %>%
select(name, location.city)
masterlist %>%
filter(location.city == "Carle Place" | location.city == "New York" | location.city == "HOUSTON") %>%
select(name, location.city, location.address1)
masterlist %>%
filter(location.city == "Carle Place" | location.city == "New York" | location.city == "HOUSTON" | location.city == "Bellaire") %>%
select(name, location.city, location.address1)
restaurant_list = list()
#THE 'TEST' FOR LOOP I'LL BE USING
offset_counter <- 1
results_returned <- 50
for(i in 1:20){
if (offset_counter == 951 ){
results_returned <- 49
}else{
results_returned <- 50
}
query_params <- list(
term = "Restaurants",
location = "Houston, TX", #need to find a way to iterate location query by zip
#sort_by = "rating", #this will filter out results with very few or low ratings
#use a while loop to break loop if less than 50 results are returned
sort_by = "distance",
limit = results_returned,
offset = offset_counter
)
response <- GET(
search_uri,
query = query_params,
add_headers(Authorization = paste("bearer", yelp_key))
)
response_text <- content(response, type = "text")
response_data <- fromJSON(response_text)
restaurants <- flatten(response_data$businesses)
#each set of restaurants pulled is added to the restaurant list
restaurant_list[[i]] <- restaurants
offset_counter <- offset_counter + 50
#Test code, ignore
#restaurants %>% select(name, location.zip_code) %>% filter(location.zip_code == 77002) %>% arrange(location.zip_code)
}
#if working, this code would compile all listed dataframes into a master dataframe, containing many restaurants
masterlist <-bind_rows(restaurant_list)
#are there any cities (Not Houston) That get returned?
masterlist %>%
unique(location.city)
names(masterlist)
masterlist %>%
unique(location.city)
masterlist
#if working, this code would compile all listed dataframes into a master dataframe, containing many restaurants
masterlist <-bind_rows(restaurant_list)
#are there any cities (Not Houston) That get returned?
masterlist %>%
unique(location.city)
masterlist
masterlist %>%
unique(location.city)
masterlist %>%
as.factor(location.city) %>%
unique(location.city)
masterlist %>%
group_by(location.city) %>%
unique(location.city)
masterlist %>%
select(location.city)
#are there any cities (Not Houston) That get returned?
masterlist %>%
unique(location.city)
restaurant_list = list()
#THE 'TEST' FOR LOOP I'LL BE USING
offset_counter <- 1
results_returned <- 50
for(i in 1:20){
if (offset_counter == 951 ){
results_returned <- 49
}else{
results_returned <- 50
}
query_params <- list(
term = "Restaurants",
location = "Houston, TX", #need to find a way to iterate location query by zip
#sort_by = "rating", #this will filter out results with very few or low ratings
#use a while loop to break loop if less than 50 results are returned
#sort_by = "distance",
limit = results_returned,
offset = offset_counter
)
response <- GET(
search_uri,
query = query_params,
add_headers(Authorization = paste("bearer", yelp_key))
)
response_text <- content(response, type = "text")
response_data <- fromJSON(response_text)
restaurants <- flatten(response_data$businesses)
#each set of restaurants pulled is added to the restaurant list
restaurant_list[[i]] <- restaurants
offset_counter <- offset_counter + 50
#Test code, ignore
#restaurants %>% select(name, location.zip_code) %>% filter(location.zip_code == 77002) %>% arrange(location.zip_code)
}
restaurant_list = list()
#THE 'TEST' FOR LOOP I'LL BE USING
offset_counter <- 1
results_returned <- 50
for(i in 1:20){
if (offset_counter == 951 ){
results_returned <- 49
}else{
results_returned <- 50
}
query_params <- list(
term = "Restaurants",
location = "Houston, TX", #need to find a way to iterate location query by zip
#sort_by = "rating", #this will filter out results with very few or low ratings
#use a while loop to break loop if less than 50 results are returned
#sort_by = "distance",
limit = results_returned,
offset = offset_counter
)
response <- GET(
search_uri,
query = query_params,
add_headers(Authorization = paste("bearer", yelp_key))
)
response_text <- content(response, type = "text")
response_data <- fromJSON(response_text)
restaurants <- flatten(response_data$businesses)
#each set of restaurants pulled is added to the restaurant list
restaurant_list[[i]] <- restaurants
offset_counter <- offset_counter + 50
#Test code, ignore
#restaurants %>% select(name, location.zip_code) %>% filter(location.zip_code == 77002) %>% arrange(location.zip_code)
}
#if working, this code would compile all listed dataframes into a master dataframe, containing many restaurants
masterlist <-bind_rows(restaurant_list)
#are there any cities (Not Houston) That get returned?
masterlist %>%
unique(location.city)
#are there any cities (Not Houston) That get returned?
masterlist %>%
unique(location.city)
masterlist %>%
unique(.$location.city)
library("magrittr")
masterlist %>%
unique(location.city)
masterlist$location.city %>%
unique()
masterlist %>%
filter(location.city == "Carle Place" | location.city == "New York" | location.city == "HOUSTON" | location.city == "Bellaire") %>%
select(name, location.city, location.address1)
restaurant_list = list()
#THE 'TEST' FOR LOOP I'LL BE USING
offset_counter <- 1
results_returned <- 50
for(i in 1:20){
if (offset_counter == 951 ){
results_returned <- 49
}else{
results_returned <- 50
}
query_params <- list(
term = "Restaurants",
location = "Houston, TX", #need to find a way to iterate location query by zip
#sort_by = "rating", #this will filter out results with very few or low ratings
#use a while loop to break loop if less than 50 results are returned
#sort_by = "distance",
attributes = "gender_neutral_bathrooms",
limit = results_returned,
offset = offset_counter
)
response <- GET(
search_uri,
query = query_params,
add_headers(Authorization = paste("bearer", yelp_key))
)
response_text <- content(response, type = "text")
response_data <- fromJSON(response_text)
restaurants <- flatten(response_data$businesses)
#each set of restaurants pulled is added to the restaurant list
restaurant_list[[i]] <- restaurants
offset_counter <- offset_counter + 50
#Test code, ignore
#restaurants %>% select(name, location.zip_code) %>% filter(location.zip_code == 77002) %>% arrange(location.zip_code)
}
#if working, this code would compile all listed dataframes into a master dataframe, containing many restaurants
masterlist <-bind_rows(restaurant_list)
names(masterlist)
masterlist %>%
select(name, location.zip_code) %>%
head(25)
response_text
restaurant_list = list()
#THE 'TEST' FOR LOOP I'LL BE USING
offset_counter <- 1
results_returned <- 50
for(i in 1:20){
if (offset_counter == 951 ){
results_returned <- 49
}else{
results_returned <- 50
}
query_params <- list(
term = "Restaurants",
location = "Houston, TX", #need to find a way to iterate location query by zip
#sort_by = "rating", #this will filter out results with very few or low ratings
#use a while loop to break loop if less than 50 results are returned
sort_by = "best_match",
attributes = "gender_neutral_bathrooms",
limit = results_returned,
offset = offset_counter
)
response <- GET(
search_uri,
query = query_params,
add_headers(Authorization = paste("bearer", yelp_key))
)
response_text <- content(response, type = "text")
response_data <- fromJSON(response_text)
restaurants <- flatten(response_data$businesses)
#each set of restaurants pulled is added to the restaurant list
restaurant_list[[i]] <- restaurants
offset_counter <- offset_counter + 50
#Test code, ignore
#restaurants %>% select(name, location.zip_code) %>% filter(location.zip_code == 77002) %>% arrange(location.zip_code)
}
#if working, this code would compile all listed dataframes into a master dataframe, containing many restaurants
masterlist <-bind_rows(restaurant_list)
masterlist %>%
select(name, location.zip_code) %>%
head(25)
restaurant_list = list()
#THE 'TEST' FOR LOOP I'LL BE USING
offset_counter <- 1
results_returned <- 50
for(i in 1:20){
if (offset_counter == 951 ){
results_returned <- 49
}else{
results_returned <- 50
}
query_params <- list(
term = "Restaurants",
location = "Houston, TX", #need to find a way to iterate location query by zip
#sort_by = "rating", #this will filter out results with very few or low ratings
#use a while loop to break loop if less than 50 results are returned
sort_by = "best_match",
attributes = "gender_neutral_restrooms",
limit = results_returned,
offset = offset_counter
)
response <- GET(
search_uri,
query = query_params,
add_headers(Authorization = paste("bearer", yelp_key))
)
response_text <- content(response, type = "text")
response_data <- fromJSON(response_text)
restaurants <- flatten(response_data$businesses)
#each set of restaurants pulled is added to the restaurant list
restaurant_list[[i]] <- restaurants
offset_counter <- offset_counter + 50
#Test code, ignore
#restaurants %>% select(name, location.zip_code) %>% filter(location.zip_code == 77002) %>% arrange(location.zip_code)
}
restaurant_list = list()
#THE 'TEST' FOR LOOP I'LL BE USING
offset_counter <- 1
results_returned <- 50
for(i in 1:20){
if (offset_counter == 951 ){
results_returned <- 49
}else{
results_returned <- 50
}
query_params <- list(
term = "Restaurants",
location = "Houston, TX", #need to find a way to iterate location query by zip
#sort_by = "rating", #this will filter out results with very few or low ratings
#use a while loop to break loop if less than 50 results are returned
sort_by = "best_match",
attributes = "gender_neutral_restrooms",
limit = results_returned,
offset = offset_counter
)
response <- GET(
search_uri,
query = query_params,
add_headers(Authorization = paste("bearer", yelp_key))
)
response_text <- content(response, type = "text")
response_data <- fromJSON(response_text)
restaurants <- flatten(response_data$businesses)
#each set of restaurants pulled is added to the restaurant list
restaurant_list[[i]] <- restaurants
offset_counter <- offset_counter + 50
#Test code, ignore
#restaurants %>% select(name, location.zip_code) %>% filter(location.zip_code == 77002) %>% arrange(location.zip_code)
}
restaurant_list = list()
#THE 'TEST' FOR LOOP I'LL BE USING
offset_counter <- 1
results_returned <- 50
restaurant_length <- 50
for(i in 1:20){
if (offset_counter == 951 ){
results_returned <- 49
}else{
results_returned <- 50
}
while(restaurant_length >= 50){
query_params <- list(
term = "Restaurants",
location = "Houston, TX", #need to find a way to iterate location query by zip
#sort_by = "rating", #this will filter out results with very few or low ratings
#use a while loop to break loop if less than 50 results are returned
sort_by = "best_match",
attributes = "gender_neutral_restrooms",
limit = results_returned,
offset = offset_counter
)
response <- GET(
search_uri,
query = query_params,
add_headers(Authorization = paste("bearer", yelp_key))
)
response_text <- content(response, type = "text")
response_data <- fromJSON(response_text)
restaurants <- flatten(response_data$businesses)
#each set of restaurants pulled is added to the restaurant list
restaurant_length = length(restaurants)
restaurant_list[[i]] <- restaurants
offset_counter <- offset_counter + 50
}
#Test code, ignore
#restaurants %>% select(name, location.zip_code) %>% filter(location.zip_code == 77002) %>% arrange(location.zip_code)
}
#if working, this code would compile all listed dataframes into a master dataframe, containing many restaurants
masterlist <-bind_rows(restaurant_list)
response_text
restaurant_list = list()
#THE 'TEST' FOR LOOP I'LL BE USING
offset_counter <- 1
results_returned <- 50
for(i in 1:4){
if (offset_counter == 951 ){
results_returned <- 49
}else{
results_returned <- 50
}
query_params <- list(
term = "Restaurants",
location = "Houston, TX", #need to find a way to iterate location query by zip
#sort_by = "rating", #this will filter out results with very few or low ratings
#use a while loop to break loop if less than 50 results are returned
sort_by = "best_match",
attributes = "gender_neutral_restrooms",
limit = results_returned,
offset = offset_counter
)
response <- GET(
search_uri,
query = query_params,
add_headers(Authorization = paste("bearer", yelp_key))
)
response_text <- content(response, type = "text")
response_data <- fromJSON(response_text)
restaurants <- flatten(response_data$businesses)
#each set of restaurants pulled is added to the restaurant list
restaurant_list[[i]] <- restaurants
offset_counter <- offset_counter + 50
#Test code, ignore
#restaurants %>% select(name, location.zip_code) %>% filter(location.zip_code == 77002) %>% arrange(location.zip_code)
}
#if working, this code would compile all listed dataframes into a master dataframe, containing many restaurants
masterlist <-bind_rows(restaurant_list)
masterlist %>%
select(name, location.zip_code) %>%
head(25)
masterlist %>%
select(name, location.zip_code) %>%
group_by(zip_code)
masterlist %>%
select(name, location.zip_code) %>%
group_by(location.zip_code)
masterlist %>%
select(name, location.zip_code) %>%
arrange(location.zip_code)
masterlist %>%
select(name, location.zip_code) %>%
count(location.zip_code)
masterlist %>%
select(name, location.zip_code) %>%
count(location.zip_code) %>%
arrange(desc(n))
